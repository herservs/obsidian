# [아키텍처] 전자결재시스템 코드 아키텍처 컨셉 정리 - 구조 비교 및 결정 이유

## 1. 개요
전자결재시스템(e-Doc) 개발을 위한 전체 코드 아키텍처를 결정하기 위해 여러 구조적 접근을 비교하고, 개발 편의성과 주요 로직 특성을 바탕으로 Layered Architecture를 중심으로 시스템 구성 방식을 정리함.

---

## 2. 아키텍처 구조 비교

### 고려한 아키텍처 후보

| 아키텍처 유형                | 설명                                   | 장점                          | 단점                             |
| ---------------------- | ------------------------------------ | --------------------------- | ------------------------------ |
| **Layered (계층형)**      | Controller → Service → Repository 구조 | 익숙하고 구현 쉬움, 테스트와 유지보수 용이    | 도메인 분리 어려움, 규모 커질수록 서비스 레이어 복잡 |
| **DDD (도메인 중심 설계)**    | 도메인 단위 모듈화 + 계층 구조 혼합                | 복잡한 도메인 분리에 적합, 구조적 명확성     | 설계 비용 큼, 도메인 지식 공유 어려움         |
| **Hexagonal (포트/어댑터)** | 입출력(I/O) 분리 중심 구조                    | 테스트 용이, SAP/DB/API 등 유연한 연동 | 구조가 복잡하고 익숙하지 않음               |

### 최종 선택: **Layered Architecture**

#### 선택 이유
- SAP 연동은 일부에 불과하며, 주 로직은 내부 결재 시스템
- 팀원들이 익숙한 구조로 빠르게 개발 가능
- 유연한 도메인 분리와 확장이 용이

#### 디렉토리 구조 예시

```
📁 controller       // API 엔드포인트
📁 service          // 비즈니스 로직
📁 repository       // DB 접근 (JPA, MyBatis 등)
📁 domain/model     // Entity, Enum, VO 등
📁 dto              // 요청/응답 구조
📁 config           // 보안, 설정, 스케줄러 등
📁 adapter.sap      // SAP 연동 (필요 시)
```

---

## 3. 결재 상태/결재선 처리 방식

### FSM (상태머신)

| 항목 | 내용 |
|------|------|
| 개념 | 문서 상태를 Enum으로 정의하고 코드 상에서 전이 조건 명시 |
| 예 | DRAFT → SUBMITTED → APPROVED → COMPLETED 등 |
| 장점 | 흐름이 명확, 구현 직관적 |
| 단점 | 결재선이 유동적일 경우 확장 어려움 |

### 정책 기반 처리

| 항목 | 내용 |
|------|------|
| 개념 | 결재 흐름을 데이터(테이블 또는 JSON)로 정의하여 유연하게 처리 |
| 예 | 부서장 → 팀장 → 본부장 식의 흐름을 JSON/DB로 정의 |
| 장점 | 유연하고 유지보수 용이 |
| 단점 | 구현 복잡도 증가, 관리 UI 필요 |

### 적용 구분 예시

| 적용 예시 | FSM 적합 | 정책 기반 적합 | 설명 |
|-----------|----------|----------------|------|
| 작성 → 결재중 → 완료 같은 기본 흐름 | ✅ | ❌ | 고정된 상태 전이 흐름은 FSM으로 충분 |
| 결재자가 문서에 따라 다름 | ❌ | ✅ | 정책 테이블에 정의하면 유연하게 처리 가능 |
| 특정 문서는 특정 직책만 결재 가능 | ❌ | ✅ | 문서 종류별 결재 조건을 정책으로 분리 |
| 결재자가 직접 결재선을 지정 | ❌ | ✅ | 사용자 입력 기반이므로 정책 기반 필수 |

### 최종 선택:  
✅ **문서 흐름은 FSM으로 관리하고**,  
✅ **결재선은 정책 기반 처리로 분리하여 유연성 확보**

---

## 4. 실시간 쿼리 vs 캐시

| 방식 | 장점 | 단점 | 적합 대상 |
|------|------|------|-----------|
| 실시간 쿼리 | 단순하고 항상 최신 데이터 | DB 부하 존재 | 결재 문서 상태, 승인 진행 등 |
| 캐시 (예: Redis) | 빠름, 부하 적음 | TTL/동기화 필요 | 부서 목록, 사용자 정보 등 자주 조회되는 데이터 |

### 최종 선택: **기본은 실시간 쿼리로 시작, 부하 발생 시 일부 마스터 데이터만 캐싱 도입**

---

## 5. 관리자/사용자 UI 구조

| 구분 | 경로 | 주요 기능 |
|------|------|-----------|
| 관리자 | `/admin/**` | 사용자 관리, 결재선 정책, 전체 문서 조회 |
| 사용자 | `/user/**` | 문서 상신, 결재, 상태 조회 등 개인화 기능 |

### 최종 선택: **관리자와 사용자 화면 완전 분리**

---

## 6. 결론 요약

| 항목 | 결정 내용 |
|------|-----------|
| 기본 구조 | Layered Architecture (Controller → Service → Repository) |
| 상태 흐름 | FSM 기반 상태 전이 |
| 결재선 처리 | 정책 기반 구조 (DB/JSON 기반 결재 흐름 관리) |
| 데이터 접근 | 실시간 쿼리 기반, 필요한 경우 캐시 도입 |
| 화면 구성 | 관리자/사용자 완전 분리 URL 구조 |
| 확장성 | 외부 연동(SAP 등)은 Adapter 구조로 분리, 도메인별 모듈화 가능 |
